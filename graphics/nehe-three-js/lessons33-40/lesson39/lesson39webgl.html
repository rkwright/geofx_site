<!DOCTYPE html>
<html lang="en">
<head>
    <!-- -------------------------------------
        Very roughly based (or inspired by) NeHe Tutorial 36
	Original:  http://nehe.gamedev.net/tutorial/playing_avi_files_in_opengl/23001/
    Largely cloned from https://medium.com/@andrew_b_berg/volumetric-light-scattering-in-three-js-6e1850680a41

    @author: rkwright@geofx.com
	-------------------------------------- -->
	<title>NEHE Lesson 39</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
	<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="../../css/NeHe.css" />

    <!-- Include several libraries from THREE.js and the Scene class  -->
	<script src="../../js/three.js" type="text/javascript"></script>
    <script src="../../js/Detector.js" type="text/javascript"></script>
    <script src="../../js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
    <script src="../../js/stats.js" type="text/javascript"></script>
    <script src="../../js/gfx-scene.js" type="text/javascript"></script>
    <script src="js/State3D.js" type="text/javascript"></script>
    <script src="js/Derivative.js" type="text/javascript"></script>
    <script src="js/Physics3D.js" type="text/javascript"></script>

</head>
<body>

	<div style="position: absolute; top: 10px; left: 10px;color:white">
		<p></p>
	</div>

	<script type="text/javascript">

			// global variables (ick)
			var cubeMesh;
			var plateMesh;
			var springMesh;


			// allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
			var gfxScene = new GFX.Scene( {
					cameraPos : [8, 6, 15],
					controls:true,
					displayStats:"fps ms"
			});

			// then initialize our demo's stuff
			initializeDemo();

			// Animate the scene
			animateScene();

			/**
			 * Initialize the Demo.
			 */
			function initializeDemo() {

					var initialPos = new THREE.Vector3(0, 5, 0);
					var initialMom = new THREE.Vector3(0, 0, 0);
					var mass = 1.0;
					var size = 1.0;

					var physics3D = new GFX.Physics3D( render, forces, initialPos, initialMom, mass, size );

					var cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
					cubeMesh = new THREE.Mesh(cubeGeometry, new THREE.MeshLambertMaterial({color:0xFF0000}));
					cubeMesh.position.set(0,10,0);
					gfxScene.add(cubeMesh);

					var plateGeometry = new THREE.BoxGeometry(3, 0.25, 3);
					plateMesh = new THREE.Mesh(plateGeometry, new THREE.MeshLambertMaterial({color:0x888888}));
					plateMesh.position.set(0,5.5,0);
					gfxScene.add(plateMesh);
			}

			function render( state ) {

					//console.log("x,y,z: " + state.position.x.toFixed(2) + " " + state.position.y.toFixed(2) + " " +
					//       state.position.z.toFixed(2));

					cubeMesh.position.set(state.position.x, state.position.y, state.position.z);
					cubeMesh.rotation.y = 2.0 *  Math.acos(state.orientation.w);

					createSpring( state.position.y );
			}

			function createSpring( posY ) {
					var h = 6 - posY;
					var cylY = 5.5 - h * 0.5;

					gfxScene.remove( springMesh );

					var springGeometry = new THREE.CylinderGeometry(0.1, 0.1, h, 32);
					springMesh = new THREE.Mesh(springGeometry, new THREE.MeshLambertMaterial({color:0x888888}));
					springMesh.position.set(0,cylY,0);
					gfxScene.add(springMesh);
			}

			// Calculate force and torque for physics state at time t.
			// Due to the way that the RK4 integrator works we need to calculate
			// force implicitly from state rather than explicitly applying forces
			// to the rigid body once per update. This is because the RK4 achieves
			// its accuracy by detecting curvature in derivative values over the
			// timestep so we need our force values to supply the curvature.
			function forces ( state, t, derivative ) {
	
					// pseudo contstants
					var FORCE_X = 0;
					var FORCE_Y = 2;
					var FORCE_Z = 0;
					var FORCE_SCALE = -5.0;
					var TORQUE_X = 0.0;
					var TORQUE_Y = 1.0;
					var TORQUE_Z = 0.0;
					var DAMPING_TORQUE = -0.5;

					// attract towards origin
					derivative.force.copy(state.position);
					derivative.force.multiplyScalar(FORCE_SCALE);

					// sine force to add some randomness to the motion
					derivative.force.x += FORCE_X; // * Math.sin(t * 0.9 + 0.5);
					derivative.force.y += FORCE_Y; // * Math.sin(t * 0.5 + 0.4);
					derivative.force.z += FORCE_Z; // * Math.sin(t * 0.5 + 0.4);

					// sine torque to get some spinning action

					derivative.torque.x = TORQUE_X; //  * Math.sin(t * 0.9 + 0.5);
					derivative.torque.y = TORQUE_Y; // * Math.sin(t * 0.5 + 0.4);
					derivative.torque.z = TORQUE_Z; // * Math.sin(t * 0.7 + 0.9);

					// damping torque so we don't spin too fast
					derivative.torque.addScaledVector( state.angularVelocity, DAMPING_TORQUE );
			}

			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {

					// Tell the browser to call this function when page is visible
					requestAnimationFrame(animateScene);

					physics3D.timeStep();

					// Map the 3D scene down to the 2D screen (render the frame)
					gfxScene.renderScene();
			}
    </script>
</body>
</html>
