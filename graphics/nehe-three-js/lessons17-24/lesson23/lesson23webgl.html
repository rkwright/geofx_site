<!DOCTYPE html>	<!-- Tells the browser that the page uses the HTML5 standard -->
<html>
	<head>
		<!-- -------------------------------------
  			Roughly based (or inspired by) NeHe Tutorial 23
  			Original:  http://nehe.gamedev.net/tutorial/sphere_mapping_quadrics_in_opengl/15005/
  
  			@author: rkwright@geofx.com
		-------------------------------------- -->
		<title>NEHE Lesson 23</title>
		<meta charset="UTF-8"/>
    <link href="../../../../images/favicon.png"  rel="shortcut icon" type="image/png" />

		<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>
		<link rel="stylesheet" type="text/css" href="../../css/NeHe.css" /> 

		<!-- Include several libraries from THREE.js and the Scene class  -->
		<script src="../../js/three.js" type="text/javascript"></script>
		<script src="../../js/Detector.js" type="text/javascript"></script>
		<script src="../../js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
		<script src="../../js/stats.js" type="text/javascript"></script>
		<script src="../../js/gfx-scene.js" type="text/javascript"></script>
	</head>
	<body>	
		<script type="text/javascript">
			var quadTexture;
			var	quadric;
			var	quadGeometry;
			var	quadMaterial;
			var	materialType = 't';	// texture, paint or wire
			var	quadType = '2';
            var backgroundScene;
            var backgroundCamera;

            // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
			var gfxScene = new GFX.Scene( { cameraPos : [0, 6, 8],
				                                        axesHeight:10,
									                    controls:true,
									                    displayStats:true });

            // then initialize our demo's stuff
			initializeDemo();
	
			// Animate the scene
			animateScene();
	
			/**
			 * Initialize the Demo.  
			 */
			function initializeDemo() {
	
				// Load an image as texture
				quadTexture = new THREE.ImageUtils.loadTexture("images/ElCapitanSphere.jpg");

				quadMaterial = makeMaterial(materialType);
	
				quadric = makeQuad(quadType);

                var background = THREE.ImageUtils.loadTexture( 'images/ElCapitanSquare.jpg' );
                var backgroundMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2, 0),
                    new THREE.MeshBasicMaterial({
                        map: background
                    }));

                backgroundMesh .material.depthTest = false;
                backgroundMesh .material.depthWrite = false;

                // Create your background scene
                backgroundScene = new THREE.Scene();
                backgroundCamera = new THREE.Camera();
                backgroundScene .add(backgroundCamera );
                backgroundScene .add(backgroundMesh );

                document.addEventListener("keypress", onDocumentKeyPress, false);
			}
	
			function makeMaterial ( matType ) {
				
				materialType = matType;
				if ( materialType === 't')
					quadMat = new THREE.MeshPhongMaterial({
					    map:quadTexture,
                        color: 0xffffff,
                        specular: 0x050505,
                        shininess: 50
					});

				else if (materialType === 'w')
					quadMat = new THREE.MeshBasicMaterial({ wireframe:true });
				else
					quadMat = new THREE.MeshLambertMaterial({ color: '#00abb1' });
				
				return quadMat;
			}
	
			function makeQuad( qType ) {
	
				quadType = qType;
				
				gfxScene.remove( quadric );
	
				switch ( quadType ) {
					case '0':
						quadGeometry = new THREE.BoxGeometry(4.0, 4.0, 4.0);
					break;		
					case '1':
						quadGeometry = new THREE.CylinderGeometry(2.0, 2.0, 4, 32);
					break;
					case '2':
						quadGeometry = new THREE.SphereGeometry(2.0, 32, 32);
                        // modify UVs to accommodate the spherized
                        var faceVertexUvs = quadGeometry.faceVertexUvs[ 0 ];
                        for ( i = 0; i < faceVertexUvs.length; i++ ) {

                            var uvs = faceVertexUvs[i];
                            var face = quadGeometry.faces[i];

                            for ( var j = 0; j < 3; j++ ) {

                                uvs[j].x = face.vertexNormals[j].x * 0.5 + 0.5;
                                uvs[j].y = face.vertexNormals[j].y * 0.5 + 0.5;

                            }
                        }
					break;
				}



				quad = new THREE.Mesh(quadGeometry, quadMaterial);
				
				gfxScene.add(quad);
				
				return quad;
			}
	
			function onDocumentKeyPress(event) {
				// Get the key code of the pressed key
				var keyChar = String.fromCharCode(event.which);
                keyChar = keyChar.toLowerCase();

				var quadString = "012";

					if ( quadString.indexOf(keyChar) !== -1) {
					quadric = makeQuad(keyChar);
				}
			}
	
			/**
			 * Animate the scene and call rendering.
			 */
			function animateScene() {
	
				// Tell the browser to call this function when page is visible
				requestAnimationFrame(animateScene);

                gfxScene.renderer.autoClear = false;
                gfxScene.renderer.clear();

				// Map the 3D scene down to the 2D screen (render the frame)
                gfxScene.renderer.render(backgroundScene , backgroundCamera );
                gfxScene.renderScene();
			}

		</script>

		<!-- Create a DIV element, which will be shown over the WebGL canvas. -->
		<div style="position: absolute; top: 10px; left: 10px;color:white">
		'0 .. 2': Type of quadric<br/>
        </div>
	</body>
</html>
